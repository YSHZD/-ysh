ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
forEach()  ,  filter()  ,  every()  和 some()  都会跳过空位。
map()  会跳过空位，但会保留这个值
join()  和 toString()  会将空位视为 undefined  ，而 undefined  和 null  会被处理成空字符
串。
// forEach 方法
[,'a'].forEach((x,i) => log(i)); // 1
// filter 方法
['a',,'b'].filter(x => true) // ['a','b']
// every 方法
[,'a'].every(x => x==='a') // true
// some 方法
[,'a'].some(x => x !== 'a') // false
// map 方法
[,'a'].map(x => 1) // [,1]
// join 方法
[,'a',undefined,null].join('#') // "#a##"
// toString 方法
[,'a',undefined,null].toString() // ",a,,"

ES6 则是明确将空位转为 undefined  。
Array.from  方法会将数组的空位，转为 undefined  ，也就是说，这个方法不会忽略空位。
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
扩展运算符（ ...  ）也会将空位转为 undefined  。
[...['a',,'b']]
// [ "a", undefined, "b" ]
copyWithin()  会连空位一起拷贝。
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]
fill()  会将空位视为正常的数组位置。
new Array(3).fill('a') // ["a","a","a"]
for...of  循环也会遍历空位。
let arr = [, ,];
for (let i of arr) {
console.log(1);
}
// 1
// 1
上面代码中，数组 arr  有两个空位， for...of  并没有忽略它们。如果改成 map  方法遍历，空位是会跳
过的。
entries()  、 keys()  、 values()  、 find()  和 findIndex()  会将空位处理成 undefined  。
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]
// keys()
[...[,'a'].keys()] // [0,1]
// values()
[...[,'a'].values()] // [undefined,"a"]
// find()
[,'a'].find(x => true) // undefined
// findIndex()
[,'a'].findIndex(x => true) // 0
由于空位的处理规则非常不统一，所以建议避免出现空位。

函数的 length 属性
指定了默认值以后，函数的 length  属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值
后， length  属性将失真。
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
上面代码中， length  属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后
一个函数，定义了 3 个参数，其中有一个参数 c  指定了默认值，因此 length  属性等于 3  减去 1  ，最后
得到 2  

这是因为 length  属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数
个数就不包括这个参数了。同理， rest 参数也不会计入 length  属性。
(function(...args) {}).length // 0
如果设置了默认值的参数不是尾参数，那么 length  属性也不再计入后面的参数了。
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1

rest 参数
ES6 引入 rest 参数（形式为 “... 变量名 ” ），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。 rest
参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
function add(...values) {
let sum = 0;
for (var val of values) {
sum += val;
}
return sum;
}
add(2, 5, 3) // 10
上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数
组 push 方法的例子。
function push(array, ...items) {
items.forEach(function(item) {
array.push(item);
console.log(item);
});
}
var a = [];
push(a, 1, 2, 3)
注意， rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
扩展运算符
含义
扩展运算符（ spread ）是三个点（ ...  ）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序
列。
function add(x, y) {
return x + y;
}
var numbers = [4, 38];
add(...numbers)

// ES5 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f.apply(null, args);
// ES6 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f(...args)

下面是扩展运算符取代 apply  方法的一个实际的例子，应用 Math.max  方法，简化求出一个数组最大元素
的写法。
// ES5 的写法
Math.max.apply(null, [14, 3, 77])
// ES6 的写法
Math.max(...[14, 3, 77])
//  等同于
Math.max(14, 3, 77);

// ES5 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);


扩展运算符的应用
（ 1 ）合并数组
扩展运算符提供了数组合并的新写法。
// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];
// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]
// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
（ 2 ）与解构赋值结合
扩展运算符可以与解构赋值结合起来，用于生成数组。
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest // [2, 3, 4, 5]
const [first, ...rest] = [];
first // undefined
rest // []:
const [first, ...rest] = ["foo"];
first // "foo"
rest // []
如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
const [...butLast, last] = [1, 2, 3, 4, 5];
//  报错
const [first, ...middle, last] = [1, 2, 3, 4, 5];
//  报错
（ 3 ）函数的返回值
JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个
问题的一种变通方法。
var dateFields = readDateFields(database);
var d = new Date(...dateFields);
上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date  。
（ 4 ）字符串
扩展运算符还可以将字符串转为真正的数组。
[...'hello']
// [ "h", "e", "l", "l", "o" ]
上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问
题。因此，正确返回字符串长度的函数，可以像下面这样写。
function length(str) {
return [...str].length;
}
length('x\uD83D\uDE80y') // 3
凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。
let str = 'x\uD83D\uDE80y';
str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'
[...str].reverse().join('')
// 'y\uD83D\uDE80x'
上面代码中，如果不用扩展运算符，字符串的 reverse  操作就不正确。
（ 5 ）实现了 Iterator 接口的对象
任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];
上面代码中， querySelectorAll  方法返回的是一个 nodeList  对象。它不是数组，而是一个类似数组的
对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList  对象实现了 Iterator 接口。
对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。
let arrayLike = {
'0': 'a',
'1': 'b',
'2': 'c',
length: 3
};
// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
上面代码中， arrayLike  是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这
时，可以改为使用 Array.from  方法将 arrayLike  转为真正的数组。
（ 6 ） Map 和 Set 结构， Generator 函数
扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算
符，比如 Map 结构。
let map = new Map([
[1, 'one'],
[2, 'two'],
[3, 'three'],
]);
let arr = [...map.keys()]; // [1, 2, 3]
Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
var go = function*(){
yield 1;
yield 2;
yield 3;
};
[...go()] // [1, 2, 3]
上面代码中，变量 go  是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展
运算符，就会将内部遍历得到的值，转为一个数组。
如果对没有 iterator  接口的对象，使用扩展运算符，将会报错。
var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object