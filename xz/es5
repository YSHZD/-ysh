ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
forEach()  ,  filter()  ,  every()  和 some()  都会跳过空位。
map()  会跳过空位，但会保留这个值
join()  和 toString()  会将空位视为 undefined  ，而 undefined  和 null  会被处理成空字符
串。
// forEach 方法
[,'a'].forEach((x,i) => log(i)); // 1
// filter 方法
['a',,'b'].filter(x => true) // ['a','b']
// every 方法
[,'a'].every(x => x==='a') // true
// some 方法
[,'a'].some(x => x !== 'a') // false
// map 方法
[,'a'].map(x => 1) // [,1]
// join 方法
[,'a',undefined,null].join('#') // "#a##"
// toString 方法
[,'a',undefined,null].toString() // ",a,,"

ES6 则是明确将空位转为 undefined  。
Array.from  方法会将数组的空位，转为 undefined  ，也就是说，这个方法不会忽略空位。
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
扩展运算符（ ...  ）也会将空位转为 undefined  。
[...['a',,'b']]
// [ "a", undefined, "b" ]
copyWithin()  会连空位一起拷贝。
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]
fill()  会将空位视为正常的数组位置。
new Array(3).fill('a') // ["a","a","a"]
for...of  循环也会遍历空位。
let arr = [, ,];
for (let i of arr) {
console.log(1);
}
// 1
// 1
上面代码中，数组 arr  有两个空位， for...of  并没有忽略它们。如果改成 map  方法遍历，空位是会跳
过的。
entries()  、 keys()  、 values()  、 find()  和 findIndex()  会将空位处理成 undefined  。
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]
// keys()
[...[,'a'].keys()] // [0,1]
// values()
[...[,'a'].values()] // [undefined,"a"]
// find()
[,'a'].find(x => true) // undefined
// findIndex()
[,'a'].findIndex(x => true) // 0
由于空位的处理规则非常不统一，所以建议避免出现空位。

函数的 length 属性
指定了默认值以后，函数的 length  属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值
后， length  属性将失真。
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
上面代码中， length  属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后
一个函数，定义了 3 个参数，其中有一个参数 c  指定了默认值，因此 length  属性等于 3  减去 1  ，最后
得到 2  

这是因为 length  属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数
个数就不包括这个参数了。同理， rest 参数也不会计入 length  属性。
(function(...args) {}).length // 0
如果设置了默认值的参数不是尾参数，那么 length  属性也不再计入后面的参数了。
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1

rest 参数
ES6 引入 rest 参数（形式为 “... 变量名 ” ），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。 rest
参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
function add(...values) {
let sum = 0;
for (var val of values) {
sum += val;
}
return sum;
}
add(2, 5, 3) // 10
上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。

rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数
组 push 方法的例子。
function push(array, ...items) {
items.forEach(function(item) {
array.push(item);
console.log(item);
});
}
var a = [];
push(a, 1, 2, 3)
注意， rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
扩展运算符
含义
扩展运算符（ spread ）是三个点（ ...  ）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序
列。
function add(x, y) {
return x + y;
}
var numbers = [4, 38];
add(...numbers)

// ES5 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f.apply(null, args);
// ES6 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f(...args)

下面是扩展运算符取代 apply  方法的一个实际的例子，应用 Math.max  方法，简化求出一个数组最大元素
的写法。
// ES5 的写法
Math.max.apply(null, [14, 3, 77])
// ES6 的写法
Math.max(...[14, 3, 77])
//  等同于
Math.max(14, 3, 77);

// ES5 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);

// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);


扩展运算符的应用
（ 1 ）合并数组
扩展运算符提供了数组合并的新写法。
// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];
// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]
// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
（ 2 ）与解构赋值结合
扩展运算符可以与解构赋值结合起来，用于生成数组。
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest // [2, 3, 4, 5]
const [first, ...rest] = [];
first // undefined
rest // []:
const [first, ...rest] = ["foo"];
first // "foo"
rest // []
如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
const [...butLast, last] = [1, 2, 3, 4, 5];
//  报错
const [first, ...middle, last] = [1, 2, 3, 4, 5];
//  报错
（ 3 ）函数的返回值
JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个
问题的一种变通方法。
var dateFields = readDateFields(database);
var d = new Date(...dateFields);
上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date  。
（ 4 ）字符串
扩展运算符还可以将字符串转为真正的数组。
[...'hello']
// [ "h", "e", "l", "l", "o" ]
上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问
题。因此，正确返回字符串长度的函数，可以像下面这样写。
function length(str) {
return [...str].length;
}
length('x\uD83D\uDE80y') // 3
凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。
let str = 'x\uD83D\uDE80y';
str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'
[...str].reverse().join('')
// 'y\uD83D\uDE80x'
上面代码中，如果不用扩展运算符，字符串的 reverse  操作就不正确。
（ 5 ）实现了 Iterator 接口的对象
任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];
上面代码中， querySelectorAll  方法返回的是一个 nodeList  对象。它不是数组，而是一个类似数组的
对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList  对象实现了 Iterator 接口。
对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。
let arrayLike = {
'0': 'a',
'1': 'b',
'2': 'c',
length: 3
};
// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
上面代码中， arrayLike  是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这
时，可以改为使用 Array.from  方法将 arrayLike  转为真正的数组。
（ 6 ） Map 和 Set 结构， Generator 函数
扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算
符，比如 Map 结构。
let map = new Map([
[1, 'one'],
[2, 'two'],
[3, 'three'],
]);
let arr = [...map.keys()]; // [1, 2, 3]
Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
var go = function*(){
yield 1;
yield 2;
yield 3;
};
[...go()] // [1, 2, 3]
上面代码中，变量 go  是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展
运算符，就会将内部遍历得到的值，转为一个数组。
如果对没有 iterator  接口的对象，使用扩展运算符，将会报错。
var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object

name 属性
函数的 name  属性，返回该函数的函数名。
function foo() {}
foo.name // "foo"
这个属性早就被浏览器广泛支持，但是直到 ES6 ，才将其写入了标准。
需要注意的是， ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量， ES5
的 name  属性，会返回空字符串，而 ES6 的 name  属性会返回实际的函数名。
var func1 = function () {};
// ES5
func1.name // ""
// ES6
func1.name // "func1"
上面代码中，变量 func1  等于一个匿名函数， ES5 和 ES6 的 name  属性返回的值不一样。
如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name  属性都返回这个具名函数原本的名字。
const bar = function baz() {};
// ES5
bar.name // "baz"
// ES6
bar.name // "baz"
Function  构造函数返回的函数实例， name  属性的值为 “anonymous” 。
(new Function).name // "anonymous"
bind  返回的函数， name  属性值会加上 “bound ” 前缀。
function foo() {};
foo.bind({}).name // "bound foo"
(function(){}).bind({}).name // "bound "

箭头函数
基本用法
ES6 允许使用 “ 箭头 ” （ =>  ）定义函数。
var f = v => v;
上面的箭头函数等同于：
var f = function(v) {
return v;
};
如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
var f = () => 5;
//  等同于
var f = function () { return 5 };
var sum = (num1, num2) => num1 + num2;
//  等同于
var sum = function(num1, num2) {
return num1 + num2;
};
如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return  语句返回。
var sum = (num1, num2) => { return num1 + num2; }
由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。
var getTempItem = id => ({ id: id, name: "Temp" });
箭头函数可以与变量解构结合使用。
const full = ({ first, last }) => first + ' ' + last;
//  等同于
function full(person) {
return person.first + ' ' + person.last;
}
箭头函数使得表达更加简洁。
const isEven = n => n % 2 == 0;
const square = n => n * n;
上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如
现在这样写醒目。
箭头函数的一个用处是简化回调函数。
//  正常函数写法
[1,2,3].map(function (x) {
return x * x;
});
//  箭头函数写法
[1,2,3].map(x => x * x);
另一个例子是
//  正常函数写法
var result = values.sort(function (a, b) {
return a - b;
});
//  箭头函数写法
var result = values.sort((a, b) => a - b);
下面是 rest 参数与箭头函数结合的例子。
const numbers = (...nums) => nums;
numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]
const headAndTail = (head, ...tail) => [head, tail];
headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
使用注意点
箭头函数有几个使用注意点。
（ 1 ）函数体内的 this  对象，就是定义时所在的对象，而不是使用时所在的对象。
（ 2 ）不可以当作构造函数，也就是说，不可以使用 new  命令，否则会抛出一个错误。
（ 3 ）不可以使用 arguments  对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替。
（ 4 ）不可以使用 yield  命令，因此箭头函数不能用作 Generator 函数。
上面四点中，第一点尤其值得注意。 this  对象的指向是可变的，但是在箭头函数中，它是固定的。
function foo() {
setTimeout(() => {
console.log('id:', this.id);
}, 100);
}
var id = 21;
foo.call({ id: 42 });
// id: 42
上面代码中， setTimeout  的参数是一个箭头函数，这个箭头函数的定义生效是在 foo  函数生成时，而它
的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this  应该指向全局对象 window  ，这时应该输
出 21  。但是，箭头函数导致 this  总是指向函数定义生效时所在的对象（本例是 {id: 42}  ），所以输
出的是 42  。
箭头函数可以让 setTimeout  里面的 this  ，绑定定义时所在的作用域，而不是指向运行时所在的作用
域。下面是另一个例子。
function Timer() {
this.s1 = 0;
this.s2 = 0;
//  箭头函数
setInterval(() => this.s1++, 1000);
//  普通函数
setInterval(function () {
this.s2++;
}, 1000);
}
var timer = new Timer();
setTimeout(() => console.log('s1: ', timer.s1), 3100);
setTimeout(() => console.log('s2: ', timer.s2), 3100);
// s1: 3
// s2: 0
上面代码中， Timer  函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的 this  绑定定
义时所在的作用域（即 Timer  函数），后者的 this  指向运行时所在的作用域（即全局对象）。所
以， 3100 毫秒之后， timer.s1  被更新了 3 次，而 timer.s2  一次都没更新。
箭头函数可以让 this  指向固定化，这种特性很有利于封装回调函数。下面是一个例子， DOM 事件的回调
函数封装在一个对象里面
