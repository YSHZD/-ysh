ArrayBuffer 对象
概述
ArrayBuffer  对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（ TypedArray  视图
和 DataView  视图 ) 来读写，视图的作用是以指定格式解读二进制数据。
ArrayBuffer  也是一个构造函数，可以分配一段可以存放数据的连续内存区域。
var buf = new ArrayBuffer(32);
上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0 。可以看到， ArrayBuffer  构造函数的参
数是所需要的内存大小（单位字节）。
为了读写这段内容，需要为它指定视图。 DataView  视图的创建，需要提供 ArrayBuffer  对象实例作为参
数。
var buf = new ArrayBuffer(32);
var dataView = new DataView(buf);
dataView.getUint8(0) // 0
上面代码对一段 32 字节的内存，建立 DataView  视图，然后以不带符号的 8 位整数格式，读取第一个元素，
结果得到 0 ，因为原始内存的 ArrayBuffer 对象，默认所有位都是 0 。
另一种 TypedArray  视图，与 DataView  视图的一个区别是，它不是一个构造函数，而是一组构造函数，
代表不同的数据格式。
var buffer = new ArrayBuffer(12);
var x1 = new Int32Array(buffer);
x1[0] = 1;
var x2 = new Uint8Array(buffer);
x2[0] = 2;
x1[0] // 2
上面代码对同一段内存，分别建立两种视图： 32 位带符号整数（ Int32Array 构造函数）和 8 位不带符号整数
（ Uint8Array 构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视
图。
TypedArray 视图的构造函数，除了接受 ArrayBuffer  实例作为参数，还可以接受普通数组作为参数，直接
分配内存生成底层的 ArrayBuffer 实例，并同时完成对这段内存的赋值。
var typedArray = new Uint8Array([0,1,2]);
typedArray.length // 3
typedArray[0] = 5;
typedArray // [5, 1, 2]
上面代码使用 TypedArray  视图的 Uint8Array  构造函数，新建一个不带符号的 8 位整数视图。可以看
到， Uint8Array  直接使用普通数组作为参数，对底层内存的赋值同时完成。

ArrayBuffer.prototype.byteLength
ArrayBuffer  实例的 byteLength  属性，返回所分配的内存区域的字节长度。
var buffer = new ArrayBuffer(32);
buffer.byteLength
// 32
如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分
配成功。
if (buffer.byteLength === n) {
//  成功
} else {
//  失败
}
ArrayBuffer.prototype.slice()
ArrayBuffer  实例有一个 slice  方法，允许将内存区域的一部分，拷贝生成一个新的 ArrayBuffer  对
象。
var buffer = new ArrayBuffer(8);
var newBuffer = buffer.slice(0, 3);
上面代码拷贝 buffer  对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新
的 ArrayBuffer  对象。 slice  方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那
个 ArrayBuffer  对象拷贝过去。
slice  方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止
的字节序号（不含该字节）。如果省略第二个参数，则默认到原 ArrayBuffer  对象的结尾。
除了 slice  方法， ArrayBuffer  对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后
通过视图读写。
ArrayBuffer.isView()
ArrayBuffer  有一个静态方法 isView  ，返回一个布尔值，表示参数是否为 ArrayBuffer  的视图实例。
这个方法大致相当于判断参数，是否为 TypedArray 实例或 DataView 实例。
var buffer = new ArrayBuffer(8);
ArrayBuffer.isView(buffer) // false
var v = new Int32Array(buffer);
ArrayBuffer.isView(v) // true

TypedArray 视图
概述
ArrayBuffer  对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，
这就叫做 “ 视图 ” （ view ）。 ArrayBuffer  有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图。
前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。
目前， TypedArray 视图一共包括 9 种类型，每一种视图都是一种构造函数。
Int8Array ： 8 位有符号整数，长度 1 个字节。
Uint8Array ： 8 位无符号整数，长度 1 个字节。
Uint8ClampedArray ： 8 位无符号整数，长度 1 个字节，溢出处理不同。
Int16Array ： 16 位有符号整数，长度 2 个字节。
Uint16Array ： 16 位无符号整数，长度 2 个字节。
Int32Array ： 32 位有符号整数，长度 4 个字节。
Uint32Array ： 32 位无符号整数，长度 4 个字节。
Float32Array ： 32 位浮点数，长度 4 个字节。
Float64Array ： 64 位浮点数，长度 8 个字节。
这 9 个构造函数生成的数组，统称为 TypedArray 视图。它们很像普通数组，都有 length  属性，都能用方括
号运算符（ []  ）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与 TypedArray 数组的差
异主要在以下方面。
TypedArray  数组的所有成员，都是同一种类型。
TypedArray  数组的成员是连续的，不会有空位。
TypedArray  数组成员的默认值为 0 。比如， new Array(10)  返回一个普通数组，里面没有任何成
员，只是 10 个空位； new Uint8Array(10)  返回一个 TypedArray 数组，里面 10 个成员都是 0 。
TypedArray  数组只是一层视图，本身不储存数据，它的数据都储存在底层的 ArrayBuffer  对象之
中，要获取底层对象必须使用 buffer  属性。
构造函数
TypedArray 数组提供 9 种构造函数，用来生成相应类型的数组实例。
构造函数有多种用法。
（ 1 ） TypedArray(buffer, byteOffset=0, length?)
同一个 ArrayBuffer  对象之上，可以根据不同的数据类型，建立多个视图。
//  创建一个 8 字节的 ArrayBuffer
var b = new ArrayBuffer(8);
//  创建一个指向 b 的 Int32 视图，开始于字节 0 ，直到缓冲区的末尾
var v1 = new Int32Array(b);
//  创建一个指向 b 的 Uint8 视图，开始于字节 2 ，直到缓冲区的末尾
var v2 = new Uint8Array(b, 2);
//  创建一个指向 b 的 Int16 视图，开始于字节 2 ，长度为 2
var v3 = new Int16Array(b, 2, 2);
上面代码在一段长度为 8 个字节的内存（ b  ）之上，生成了三个视图： v1  、 v2  和 v3  。
视图的构造函数可以接受三个参数：
第一个参数（必需）：视图对应的底层 ArrayBuffer  对象。
第二个参数（可选）：视图开始的字节序号，默认从 0 开始。
第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。
因此， v1  、 v2  和 v3  是重叠的： v1[0]  是一个 32 位整数，指向字节 0 ～字节 3 ； v2[0]  是一个 8 位无
符号整数，指向字节 2 ； v3[0]  是一个 16 位整数，指向字节 2 ～字节 3 。只要任何一个视图对内存有所修改，
就会在另外两个视图上反应出来。
注意， byteOffset  必须与所要建立的数据类型一致，否则会报错。
var buffer = new ArrayBuffer(8);
var i16 = new Int16Array(buffer, 1);
// Uncaught RangeError: start offset of Int16Array should be a multiple of 2
上面代码中，新生成一个 8 个字节的 ArrayBuffer  对象，然后在这个对象的第一个字节，建立带符号的 16 位
整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以 byteOffset  参数必须能够被 2 整除。
如果想从任意字节开始解读 ArrayBuffer  对象，必须使用 DataView  视图，因为 TypedArray  视图只提
供 9 种固定的解读格式。
（ 2 ） TypedArray(length)
视图还可以不通过 ArrayBuffer  对象，直接分配内存而生成。
var f64a = new Float64Array(8);
f64a[0] = 10;
f64a[1] = 20;
f64a[2] = f64a[0] + f64a[1];
上面代码生成一个 8 个成员的 Float64Array  数组（共 64 字节），然后依次对每个成员赋值。这时，视图构
造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。
（ 3 ） TypedArray(typedArray)
TypedArray 数组的构造函数，可以接受另一个 TypedArray 实例作为参数。
var typedArray = new Int8Array(new Uint8Array(4));
上面代码中， Int8Array  构造函数接受一个 Uint8Array  实例作为参数。
注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的
内存储存数据，不会在原数组的内存之上建立视图。
var x = new Int8Array([1, 1]);
var y = new Int8Array(x);
x[0] // 1
y[0] // 1
x[0] = 2;
y[0] // 1
上面代码中，数组 y  是以数组 x  为模板而生成的，当 x  变动的时候， y  并没有变动。
如果想基于同一段内存，构造不同的视图，可以采用下面的写法。
var x = new Int8Array([1, 1]);
var y = new Int8Array(x.buffer);
x[0] // 1
y[0] // 1
x[0] = 2;
y[0] // 2
（ 4 ） TypedArray(arrayLikeObject)
构造函数的参数也可以是一个普通数组，然后直接生成 TypedArray 实例。
var typedArray = new Uint8Array([1, 2, 3, 4]);
注意，这时 TypedArray 视图会重新开辟内存，不会在原数组的内存上建立视图。
上面代码从一个普通的数组，生成一个 8 位无符号整数的 TypedArray  实例。
TypedArray  数组也可以转换回普通数组。
var normalArray = Array.prototype.slice.call(typedArray);
数组方法
普通数组的操作方法和属性，对 TypedArray 数组完全适用。
TypedArray.prototype.copyWithin(target, start[, end = this.length])
TypedArray.prototype.entries()
TypedArray.prototype.every(callbackfn, thisArg?)
TypedArray.prototype.fill(value, start=0, end=this.length)
TypedArray.prototype.filter(callbackfn, thisArg?)
TypedArray.prototype.find(predicate, thisArg?)
TypedArray.prototype.findIndex(predicate, thisArg?)
TypedArray.prototype.forEach(callbackfn, thisArg?)
TypedArray.prototype.indexOf(searchElement, fromIndex=0)
TypedArray.prototype.join(separator)
TypedArray.prototype.keys()
TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)
TypedArray.prototype.map(callbackfn, thisArg?)
TypedArray.prototype.reduce(callbackfn, initialValue?)
TypedArray.prototype.reduceRight(callbackfn, initialValue?)
TypedArray.prototype.reverse()
TypedArray.prototype.slice(start=0, end=this.length)
TypedArray.prototype.some(callbackfn, thisArg?)
TypedArray.prototype.sort(comparefn)
TypedArray.prototype.toLocaleString(reserved1?, reserved2?)
TypedArray.prototype.toString()
TypedArray.prototype.values()
上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。
注意， TypedArray 数组没有 concat  方法。如果想要合并多个 TypedArray 数组，可以用下面这个函数。
function concatenate(resultConstructor, ...arrays) {
let totalLength = 0;
for (let arr of arrays) {
totalLength += arr.length;
}
let result = new resultConstructor(totalLength);
let offset = 0;
for (let arr of arrays) {
result.set(arr, offset);
offset += arr.length;
}
return result;
}
concatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4))
// Uint8Array [1, 2, 3, 4]
另外， TypedArray  数组与普通数组一样，部署了 Iterator 接口，所以可以被遍历。
let ui8 = Uint8Array.of(0, 1, 2);
for (let byte of ui8) {
console.log(byte);
}
// 0
// 1
// 2

字节序
字节序指的是数值在内存中的表示方式。
var buffer = new ArrayBuffer(16);
var int32View = new Int32Array(buffer);
for (var i = 0; i < int32View.length; i++) {
int32View[i] = i * 2;
}
上面代码生成一个 16 字节的 ArrayBuffer  对象，然后在它的基础上，建立了一个 32 位整数的视图。由于每
个 32 位整数占据 4 个字节，所以一共可以写入 4 个整数，依次为 0 ， 2 ， 4 ， 6 。
如果在这段数据上接着建立一个 16 位整数的视图，则可以读出完全不一样的结果。
var int16View = new Int16Array(buffer);
for (var i = 0; i < int16View.length; i++) {
console.log("Entry " + i + ": " + int16View[i]);
}
// Entry 0: 0
// Entry 1: 0
// Entry 2: 2
// Entry 3: 0
// Entry 4: 4
// Entry 5: 0
// Entry 6: 6
// Entry 7: 0
由于每个 16 位整数占据 2 个字节，所以整个 ArrayBuffer 对象现在分成 8 段。然后，由于 x86 体系的计算机都采用
小端字节序（ little endian ），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，
所以就得到了上面的结果。
比如，一个占据四个字节的 16 进制数 0x12345678  ，决定其大小的最重要的字节是 “12” ，最不重要的
是 “78” 。小端字节序将最不重要的字节排在前面，储存顺序就是 78563412  ；大端字节序则完全相反，将最
重要的字节排在前面，储存顺序就是 12345678  。目前，所有个人电脑几乎都是小端字节序，所以
TypedArray 数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数
据。
这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一
个严重的问题：如果一段数据是大端字节序， TypedArray 数组将无法正确解析，因为它只能处理小端字节
序！为了解决这个问题， JavaScript 引入 DataView  对象，可以设定字节序，下文会详细介绍。
下面是另一个例子。
//  假定某段 buffer 包含如下字节 [0x02, 0x01, 0x03, 0x07]
var buffer = new ArrayBuffer(4);
var v1 = new Uint8Array(buffer);
v1[0] = 2;
v1[1] = 1;
v1[2] = 3;
v1[3] = 7;
var uInt16View = new Uint16Array(buffer);
//  计算机采用小端字节序
//  所以头两个字节等于 258
if (uInt16View[0] === 258) {
console.log('OK'); // "OK"
}
//  赋值运算
uInt16View[0] = 255; //  字节变为 [0xFF, 0x00, 0x03, 0x07]
uInt16View[0] = 0xff05; //  字节变为 [0x05, 0xFF, 0x03, 0x07]
uInt16View[1] = 0x0210; //  字节变为 [0x05, 0xFF, 0x10, 0x02]
下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。
const BIG_ENDIAN = Symbol('BIG_ENDIAN');
const LITTLE_ENDIAN = Symbol('LITTLE_ENDIAN');
function getPlatformEndianness() {
let arr32 = Uint32Array.of(0x12345678);
let arr8 = new Uint8Array(arr32.buffer);
switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {
case 0x12345678:
return BIG_ENDIAN;
case 0x78563412:
return LITTLE_ENDIAN;
default:
throw new Error('Unknown endianness');
}
}
总之，与普通数组相比， TypedArray 数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速
度快得多。


BYTES_PER_ELEMENT 属性
每一种视图的构造函数，都有一个 BYTES_PER_ELEMENT  属性，表示这种数据类型占据的字节数。
Int8Array.BYTES_PER_ELEMENT // 1
Uint8Array.BYTES_PER_ELEMENT // 1
Int16Array.BYTES_PER_ELEMENT // 2
Uint16Array.BYTES_PER_ELEMENT // 2
Int32Array.BYTES_PER_ELEMENT // 4
Uint32Array.BYTES_PER_ELEMENT // 4
Float32Array.BYTES_PER_ELEMENT // 4
Float64Array.BYTES_PER_ELEMENT // 8
这个属性在 TypedArray  实例上也能获取，即有 TypedArray.prototype.BYTES_PER_ELEMENT  



ArrayBuffer 与字符串的互相转换
ArrayBuffer  转为字符串，或者字符串转为 ArrayBuffer  ，有一个前提，即字符串的编码方法是确定
的。假定字符串采用 UTF-16 编码（ JavaScript 的内部编码方式），可以自己编写转换函数。
// ArrayBuffer 转为字符串，参数为 ArrayBuffer 对象
function ab2str(buf) {
return String.fromCharCode.apply(null, new Uint16Array(buf));
}
//  字符串转为 ArrayBuffer 对象，参数为字符串
function str2ab(str) {
var buf = new ArrayBuffer(str.length * 2); //  每个字符占用 2 个字节
var bufView = new Uint16Array(buf);
for (var i = 0, strLen = str.length; i < strLen; i++) {
bufView[i] = str.charCodeAt(i);
}
return buf;
}


溢出
不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如， 8 位视图只能容纳
一个 8 位的二进制值，如果放入一个 9 位的值，就会溢出。
TypedArray 数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。
var uint8 = new Uint8Array(1);
uint8[0] = 256;
uint8[0] // 0
uint8[0] = -1;
uint8[0] // 255

上面代码中， uint8  是一个 8 位视图，而 256 的二进制形式是一个 9 位的值 100000000  ，这时就会发生溢
出。根据规则，只会保留后 8 位，即 00000000  。 uint8  视图的解释规则是无符号的 8 位整数，所
以 00000000  就是 0  。
负数在计算机内部采用 “2 的补码 ” 表示，也就是说，将对应的正数值进行否运算，然后加 1  。比如， -
1  对应的正值是 1  ，进行否运算以后，得到 11111110  ，再加上 1  就是补码形
式 11111111  。 uint8  按照无符号的 8 位整数解释 11111111  ，返回结果就是 255  。
一个简单转换规则，可以这样表示。
正向溢出（ overflow ）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余
值，再减去 1 。
负向溢出（ underflow ）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余
值，再加上 1 。
请看下面的例子。
var int8 = new Int8Array(1);
int8[0] = 128;
int8[0] // -128
int8[0] = -129;
int8[0] // 127
上面例子中， int8  是一个带符号的 8 位整数视图，它的最大值是 127 ，最小值是 -128 。输入值为 128  时，
相当于正向溢出 1  ，根据 “ 最小值加上余值，再减去 1” 的规则，就会返回 -128  ；输入值为 -129  时，相
当于负向溢出 1  ，根据 “ 最大值减去余值，再加上 1” 的规则，就会返回 127  。
Uint8ClampedArray  视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当
前数据类型的最大值，即 255 ；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0 。
var uint8c = new Uint8ClampedArray(1);
uint8c[0] = 256;
uint8c[0] // 255
uint8c[0] = -1;
uint8c[0] // 0
上面例子中， uint8C  是一个 Uint8ClampedArray  视图，正向溢出时都返回 255 ，负向溢出都返回 0 


TypedArray.prototype.buffer
TypedArray 实例的 buffer 属性，返回整段内存区域对应的 ArrayBuffer  对象。该属性为只读属性。
var a = new Float32Array(64);
var b = new Uint8Array(a.buffer);
上面代码的 a  视图对象和 b  视图对象，对应同一个 ArrayBuffer  对象，即同一段内存。

TypedArray.prototype.byteLength ， TypedArray.prototype.byteOffset
byteLength  属性返回 TypedArray 数组占据的内存长度，单位为字节。 byteOffset  属性返回 TypedArray
数组从底层 ArrayBuffer  对象的哪个字节开始。这两个属性都是只读属性。
var b = new ArrayBuffer(8);
var v1 = new Int32Array(b);
var v2 = new Uint8Array(b, 2);
var v3 = new Int16Array(b, 2, 2);
v1.byteLength // 8
v2.byteLength // 6
v3.byteLength // 4
v1.byteOffset // 0
v2.byteOffset // 2
v3.byteOffset // 2
TypedArray.prototype.length
length  属性表示 TypedArray 数组含有多少个成员。注意将 byteLength  属性和 length  属性区分，前者
是字节长度，后者是成员长度。
var a = new Int16Array(8);
a.length // 8
a.byteLength // 16
TypedArray.prototype.set()
TypedArray 数组的 set  方法用于复制数组（普通数组或 TypedArray 数组），也就是将一段内容完全复制到
另一段内存。
var a = new Uint8Array(8);
var b = new Uint8Array(8);
b.set(a);
上面代码复制 a  数组的内容到 b  数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。
set  方法还可以接受第二个参数，表示从 b  对象的哪一个成员开始复制 a  对象。
var a = new Uint16Array(8);
var b = new Uint16Array(10);
b.set(a, 2)
上面代码的 b  数组比 a  数组多两个成员，所以从 b[2]  开始复制。



TypedArray.prototype.subarray()
subarray  方法是对于 TypedArray 数组的一部分，再建立一个新的视图。
var a = new Uint16Array(8);
var b = a.subarray(2,3);
a.byteLength // 16
b.byteLength // 2
subarray  方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略
则包含剩余的全部成员。所以，上面代码的 a.subarray(2,3)  ，意味着 b 只包含 a[2]  一个成员，字节长
度为 2 。
TypedArray.prototype.slice()
TypeArray 实例的 slice  方法，可以返回一个指定位置的新的 TypedArray 实例。
let ui8 = Uint8Array.of(0, 1, 2);
ui8.slice(-1)
// Uint8Array [ 2 ]
上面代码中， ui8  是 8 位无符号整数数组视图的一个实例。它的 slice  方法可以从当前视图之中，返回一
个新的视图实例。
slice  方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即 -1 为倒数第一个
位置， -2 表示倒数第二个位置，以此类推。

TypedArray.of()
TypedArray 数组的所有构造函数，都有一个静态方法 of  ，用于将参数转为一个 TypedArray 实例。
Float32Array.of(0.151, -8, 3.7)
// Float32Array [ 0.151, -8, 3.7 ]
下面三种方法都会生成同样一个 TypedArray 数组。
//  方法一
let tarr = new Uint8Array([1,2,3]);
//  方法二
let tarr = Uint8Array.of(1,2,3);
//  方法三
let tarr = new Uint8Array(3);
tarr[0] = 0;
tarr[1] = 1;
tarr[2] = 2;

TypedArray.from()
静态方法 from  接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的 TypedArray 实
例。
Uint16Array.from([0, 1, 2])
// Uint16Array [ 0, 1, 2 ]
这个方法还可以将一种 TypedArray 实例，转为另一种。
var ui16 = Uint16Array.from(Uint8Array.of(0, 1, 2));
ui16 instanceof Uint16Array // true
from  方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似 map  方法。
Int8Array.of(127, 126, 125).map(x => 2 * x)
// Int8Array [ -2, -4, -6 ]
Int16Array.from(Int8Array.of(127, 126, 125), x => 2 * x)
// Int16Array [ 254, 252, 250 ]
上面的例子中， from  方法没有发生溢出，这说明遍历是针对新生成的 16 位整数数组，而不是针对原来的 8
位整数数组。也就是说， from  会将第一个参数指定的 TypedArray 数组，拷贝到另一段内存之中（占用内存
从 3 字节变为 6 字节），然后再进行处理。

复合视图
由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这
叫做 “ 复合视图 ” 。
var buffer = new ArrayBuffer(24);
var idView = new Uint32Array(buffer, 0, 1);
var usernameView = new Uint8Array(buffer, 4, 16);
var amountDueView = new Float32Array(buffer, 20, 1);
上面代码将一个 24 字节长度的 ArrayBuffer 对象，分成三个部分：
字节 0 到字节 3 ： 1 个 32 位无符号整数
字节 4 到字节 19 ： 16 个 8 位整数
字节 20 到字节 23 ： 1 个 32 位浮点数



DataView 视图
如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立 ArrayBuffer  对象的复合视
图以外，还可以通过 DataView  视图进行操作。
DataView  视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上， ArrayBuffer  对象的各
种 TypedArray 视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；
而 DataView  视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行
设定的。
DataView  视图本身也是构造函数，接受一个 ArrayBuffer  对象作为参数，生成视图。
DataView(ArrayBuffer buffer [,  字节起始位置 [,  长度 ]]);
下面是一个例子。
var buffer = new ArrayBuffer(24);
var dv = new DataView(buffer);


DataView  实例有以下属性，含义与 TypedArray  实例的同名方法相同。
DataView.prototype.buffer ：返回对应的 ArrayBuffer 对象
DataView.prototype.byteLength ：返回占据的内存字节长度
DataView.prototype.byteOffset ：返回当前视图从对应的 ArrayBuffer 对象的哪个字节开始
DataView  实例提供 8 个方法读取内存。
getInt8 ：读取 1 个字节，返回一个 8 位整数。
getUint8 ：读取 1 个字节，返回一个无符号的 8 位整数。
getInt16 ：读取 2 个字节，返回一个 16 位整数。
getUint16 ：读取 2 个字节，返回一个无符号的 16 位整数。
getInt32 ：读取 4 个字节，返回一个 32 位整数。
getUint32 ：读取 4 个字节，返回一个无符号的 32 位整数。
getFloat32 ：读取 4 个字节，返回一个 32 位浮点数。
getFloat64 ：读取 8 个字节，返回一个 64 位浮点数。
这一系列 get 方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。
var buffer = new ArrayBuffer(24);
var dv = new DataView(buffer);
//  从第 1 个字节读取一个 8 位无符号整数
var v1 = dv.getUint8(0);
//  从第 2 个字节读取一个 16 位无符号整数
var v2 = dv.getUint16(1);
//  从第 4 个字节读取一个 16 位无符号整数
var v3 = dv.getUint16(3);
上面代码读取了 ArrayBuffer  对象的前 5 个字节，其中有一个 8 位整数和两个十六位整数。
如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认
情况下， DataView  的 get  方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须
在 get  方法的第二个参数指定 true  。
//  小端字节序
var v1 = dv.getUint16(1, true);
//  大端字节序
var v2 = dv.getUint16(3, false);
//  大端字节序
var v3 = dv.getUint16(3);
DataView 视图提供 8 个方法写入内存。
setInt8 ：写入 1 个字节的 8 位整数。
setUint8 ：写入 1 个字节的 8 位无符号整数。
setInt16 ：写入 2 个字节的 16 位整数。
setUint16 ：写入 2 个字节的 16 位无符号整数。
setInt32 ：写入 4 个字节的 32 位整数。
setUint32 ：写入 4 个字节的 32 位无符号整数。
setFloat32 ：写入 4 个字节的 32 位浮点数。
setFloat64 ：写入 8 个字节的 64 位浮点数。
这一系列 set 方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的
数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数， false 或者 undefined 表示使用大端字
节序写入， true 表示使用小端字节序写入。
//  在第 1 个字节，以大端字节序写入值为 25 的 32 位整数
dv.setInt32(0, 25, false);
//  在第 5 个字节，以大端字节序写入值为 25 的 32 位整数
dv.setInt32(4, 25);
//  在第 9 个字节，以小端字节序写入值为 2.5 的 32 位浮点数
dv.setFloat32(8, 2.5, true);

如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。
var littleEndian = (function() {
var buffer = new ArrayBuffer(2);
new DataView(buffer).setInt16(0, 256, true);
return new Int16Array(buffer)[0] === 256;
})();
如果返回 true  ，就是小端字节序；如果返回 false  ，就是大端字节序




二进制数组的应用
大量的 Web API 用到了 ArrayBuffer  对象和它的视图对象


AJAX


传统上，服务器通过 AJAX 操作只能返回文本数据，即 responseType  属性默认
为 text  。 XMLHttpRequest  第二版 XHR2  允许服务器返回二进制数据，这时分成两种情况。如果明确知
道返回的二进制数据类型，可以把返回类型（ responseType  ）设为 arraybuffer  ；如果不知道，就设
为 blob  。
var xhr = new XMLHttpRequest();
xhr.open('GET', someUrl);
xhr.responseType = 'arraybuffer';
xhr.onload = function () {
let arrayBuffer = xhr.response;
// ···
};
xhr.send();
如果知道传回来的是 32 位整数，可以像下面这样处理。
xhr.onreadystatechange = function () {
if (req.readyState === 4 ) {
var arrayResponse = xhr.response;
var dataView = new DataView(arrayResponse);
var ints = new Uint32Array(dataView.byteLength / 4);
xhrDiv.style.backgroundColor = "#00FF00";
xhrDiv.innerText = "Array is " + ints.length + "uints long";
}
}

Canvas

网页 Canvas  元素输出的二进制像素数据，就是 TypedArray 数组。
var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d');
var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
var uint8ClampedArray = imageData.data;
需要注意的是，上面代码的 typedArray  虽然是一个 TypedArray 数组，但是它的视图类型是一种针
对 Canvas  元素的专有类型 Uint8ClampedArray  。这个视图类型的特点，就是专门针对颜色，把每个字节
解读为无符号的 8 位整数，即只能取值 0 ～ 255 ，而且发生运算的时候自动过滤高位溢出。这为图像处理带来
了巨大的方便。
举例来说，如果把像素的颜色值设为 Uint8Array  类型，那么乘以一个 gamma 值的时候，就必须这样计算：
u8[i] = Math.min(255, Math.max(0, u8[i] * gamma));
因为 Uint8Array  类型对于大于 255 的运算结果（比如 0xFF+1 ），会自动变为 0x00 ，所以图像处理必须要像
上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为 Uint8ClampedArray  类型，计算就简化许
多。
pixels[i] *= gamma;
Uint8ClampedArray  类型确保将小于 0 的值设为 0 ，将大于 255 的值设为 255 。注意， IE 10 不支持该类型


WebSocket

WebSocket  可以通过 ArrayBuffer  ，发送或接收二进制数据。
var socket = new WebSocket('ws://127.0.0.1:8081');
socket.binaryType = 'arraybuffer';
// Wait until socket is open
socket.addEventListener('open', function (event) {
// Send binary data
var typedArray = new Uint8Array(4);
socket.send(typedArray.buffer);
});
// Receive binary data
socket.addEventListener('message', function (event) {
var arrayBuffer = event.data;
// ···
});


Fetch API

Fetch API 取回的数据，就是 ArrayBuffer  对象。
fetch(url)
.then(function(request){
return request.arrayBuffer()
})
.then(function(arrayBuffer){
// ...
});

File API

如果知道一个文件的二进制数据类型，也可以将这个文件读取为 ArrayBuffer 对象。
var fileInput = document.getElementById('fileInput');
var file = fileInput.files[0];
var reader = new FileReader();
reader.readAsArrayBuffer(file);
reader.onload = function () {
var arrayBuffer = reader.result;
// ···
};
下面以处理 bmp 文件为例。假定 file  变量是一个指向 bmp 文件的文件对象，首先读取文件。
var reader = new FileReader();
reader.addEventListener("load", processimage, false);
reader.readAsArrayBuffer(file);

然后，定义处理图像的回调函数：先在二进制数据之上建立一个 DataView 视图，再建立一个 bitmap 对象，用
于存放处理后的数据，最后将图像展示在 canvas 元素之中。
function processimage(e) {
var buffer = e.target.result;
var datav = new DataView(buffer);
var bitmap = {};
//  具体的处理步骤
}
具体处理图像数据时，先处理 bmp 的文件头。具体每个文件头的格式和定义，请参阅有关资料。
bitmap.fileheader = {};
bitmap.fileheader.bfType = datav.getUint16(0, true);
bitmap.fileheader.bfSize = datav.getUint32(2, true);
bitmap.fileheader.bfReserved1 = datav.getUint16(6, true);
bitmap.fileheader.bfReserved2 = datav.getUint16(8, true);
bitmap.fileheader.bfOffBits = datav.getUint32(10, true);
接着处理图像元信息部分。
bitmap.infoheader = {};
bitmap.infoheader.biSize = datav.getUint32(14, true);
bitmap.infoheader.biWidth = datav.getUint32(18, true);
bitmap.infoheader.biHeight = datav.getUint32(22, true);
bitmap.infoheader.biPlanes = datav.getUint16(26, true);
bitmap.infoheader.biBitCount = datav.getUint16(28, true);
bitmap.infoheader.biCompression = datav.getUint32(30, true);
bitmap.infoheader.biSizeImage = datav.getUint32(34, true);
bitmap.infoheader.biXPelsPerMeter = datav.getUint32(38, true);
bitmap.infoheader.biYPelsPerMeter = datav.getUint32(42, true);
bitmap.infoheader.biClrUsed = datav.getUint32(46, true);
bitmap.infoheader.biClrImportant = datav.getUint32(50, true);
最后处理图像本身的像素信息。
var start = bitmap.fileheader.bfOffBits;
bitmap.pixels = new Uint8Array(buffer, start);
至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在
Canvas 网页元素之中。

Set 和 Map 数据结构
Set
基本用法
ES6 提供了新的数据结构 Set 。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set 本身是一个构造函数，用来生成 Set 数据结构。
var s = new Set();
[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));
for (let i of s) {
console.log(i);
}
// 2 3 5 4
上面代码通过 add  方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。
Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。
//  例一
var set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]
//  例二
var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5
//  例三
function divs () {
return [...document.querySelectorAll('div')];
}
var set = new Set(divs());
set.size // 56
//  类似于
divs().forEach(div => set.add(div));
set.size // 56
上面代码中，例一和例二都是 Set  函数接受数组作为参数，例三是接受类似数组的对象作为参数。
上面代码中，也展示了一种去除数组重复成员的方法。

//  去除数组的重复成员
[...new Set(array)]

向 Set 加入值的时候，不会发生类型转换，所以 5  和 "5"  是两个不同的值。 Set 内部判断两个值是否不同，
使用的算法叫做 “Same-value equality” ，它类似于精确相等运算符（ ===  ），主要的区别是 NaN  等于自
身，而精确相等运算符认为 NaN  不等于自身。
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
上面代码向 Set 实例添加了两个 NaN  ，但是只能加入一个。这表明，在 Set 内部，两个 NaN  是相等。
另外，两个对象总是不相等的。
let set = new Set();
set.add({});
set.size // 1
set.add({});
set.size // 2
上面代码表示，由于两个空对象不相等，所以它们被视为两个值。

Set 实例的属性和方法
Set 结构的实例有以下属性。
Set.prototype.constructor  ：构造函数，默认就是 Set  函数。
Set.prototype.size  ：返回 Set  实例的成员总数。
Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作
方法。
add(value)  ：添加某个值，返回 Set 结构本身。
delete(value)  ：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)  ：返回一个布尔值，表示该值是否为 Set  的成员。
clear()  ：清除所有成员，没有返回值。
上面这些属性和方法的实例如下。
s.add(1).add(2).add(2);
//  注意 2 被加入了两次
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false
s.delete(2);
s.has(2) // false
下面是一个对比，看看在判断是否包括一个键上面， Object  结构和 Set  结构的写法不同。
//  对象的写法
var properties = {
'width': 1,
'height': 1
};
if (properties[someName]) {
// do something
}
// Set 的写法
var properties = new Set();
properties.add('width');
properties.add('height');
if (properties.has(someName)) {
// do something
}
Array.from  方法可以将 Set 结构转为数组。
var items = new Set([1, 2, 3, 4, 5]);
var array = Array.from(items);
这就提供了去除数组重复成员的另一种方法。
function dedupe(array) {
return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]
[...new Set(array)]
遍历操作
Set 结构的实例有四个遍历方法，可以用于遍历成员。
keys()  ：返回一个键名的遍历器
values()  ：返回一个键值的遍历器
entries()  ：返回一个键值对的遍历器
forEach()  ：使用回调函数遍历每个成员
key  方法、 value  方法、 entries  方法返回的都是遍历器对象（详见《 Iterator 对象》一章）。由于 Set
结构没有键名，只有键值（或者说键名和键值是同一个值），所以 key  方法和 value  方法的行为完全一
致。
let set = new Set(['red', 'green', 'blue']);
for (let item of set.keys()) {
console.log(item);
}
// red
// green
// blue
for (let item of set.values()) {
console.log(item);
}
// red
// green
// blue
for (let item of set.entries()) {
console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
上面代码中， entries  方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员
完全相等。
Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的 values  方法。
Set.prototype[Symbol.iterator] === Set.prototype.values
// true
这意味着，可以省略 values  方法，直接用 for...of  循环遍历 Set 。
let set = new Set(['red', 'green', 'blue']);
for (let x of set) {
console.log(x);
}
// red
// green
// blue
由于扩展运算符（ ...  ）内部使用 for...of  循环，所以也可以用于 Set 结构。
let set = new Set(['red', 'green', 'blue']);
let arr = [...set];
// ['red', 'green', 'blue']
扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
而且，数组的 map  和 filter  方法也可以用于 Set 了。
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));
//  返回 Set 结构： {2, 4, 6}
let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => (x % 2) == 0));
//  返回 Set 结构： {2, 4}
因此使用 Set ，可以很容易地实现并集（ Union ）、交集（ Intersect ）和差集（ Difference ）。
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
//  并集
let union = new Set([...a, ...b]);
// [1, 2, 3, 4]
//  交集
let intersect = new Set([...a].filter(x => b.has(x)));
// [2, 3]
//  差集
let difference = new Set([...a].filter(x => !b.has(x)));
// [1]

Set 结构的实例的 forEach  方法，用于对每个成员执行某种操作，没有返回值。
let set = new Set([1, 2, 3]);
set.forEach((value, key) => console.log(value * 2) )
// 2
// 4
// 6
上面代码说明， forEach  方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上
例省略了该参数）。另外， forEach  方法还可以有第二个参数，表示绑定的 this 对象。
如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原
Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用 Array.from 方法。
//  方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set 的值是 2, 4, 6
//  方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set 的值是 2, 4, 6
上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。

WeakSet
WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
首先， WeakSet 的成员只能是对象，而不能是其他类型的值。
其次， WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他
对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于
WeakSet 之中。这个特点意味着，无法引用 WeakSet 的成员，因此 WeakSet 是不可遍历的。
var ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
上面代码试图向 WeakSet 添加一个数值和 Symbol  值，结果报错，因为 WeakSet 只能放置对象。
WeakSet 是一个构造函数，可以使用 new  命令，创建 WeakSet 数据结构。
var ws = new WeakSet();
作为构造函数， WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 iterable 接口的
对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。
var a = [[1,2], [3,4]];
var ws = new WeakSet(a);
上面代码中， a  是一个数组，它有两个成员，也都是数组。将 a  作为 WeakSet 构造函数的参数， a  的成
员会自动成为 WeakSet 的成员。
注意，是 a  数组的成员成为 WeakSet 的成员，而不是 a  数组本身。这意味着，数组的成员只能是对象。
var b = [3, 4];
var ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
上面代码中，数组 b  的成员不是对象，加入 WeaKSet 就会报错。
WeakSet 结构有以下三个方法。
WeakSet.prototype.add(value) ：向 WeakSet 实例添加一个新成员。
WeakSet.prototype.delete(value) ：清除 WeakSet 实例的指定成员。
WeakSet.prototype.has(value) ：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
下面是一个例子。
var ws = new WeakSet();
var obj = {};
var foo = {};
ws.add(window);
ws.add(obj);
ws.has(window); // true
ws.has(foo); // false
ws.delete(window);
ws.has(window); // false
WeakSet 没有 size  属性，没有办法遍历它的成员。
ws.size // undefined
ws.forEach // undefined
ws.forEach(function(item){ console.log('WeakSet has ' + item)})
// TypeError: undefined is not a function
上面代码试图获取 size  和 forEach  属性，结果都不能成功。
WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍
历结束，成员就取不到了。 WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会
引发内存泄漏。
下面是 WeakSet 的另一个例子。
const foos = new WeakSet()
class Foo {
constructor() {
foos.add(this)
}
method () {
if (!foos.has(this)) {
throw new TypeError('Foo.prototype.method  只能在 Foo 的实例上调用！ ');
}
}
}
上面代码保证了 Foo  的实例方法，只能在 Foo  的实例上调用。这里使用 WeakSet 的好处是， foos  对实
例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑 foos  ，也不会出现内存泄漏。

Map


Map 结构的目的和基本用法
JavaScript 的对象（ Object ），本质上是键值对的集合（ Hash 结构），但是只能用字符串当作键。这给它的使
用带来了很大的限制。
var data = {};
var element = document.getElementById("myDiv");
data[element] = metadata;
data["[Object HTMLDivElement]"] // metadata
上面代码原意是将一个 DOM 节点作为对象 data 的键，但是由于对象只接受字符串作为键名，所以 element 被自
动转为字符串 [Object HTMLDivElement]  。
为了解决这个问题， ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是 “ 键 ” 的范围不限于字
符串，各种类型的值（包括对象）都可以当作键。也就是说， Object 结构提供了 “ 字符串 — 值 ” 的对应， Map 结
构提供了 “ 值 — 值 ” 的对应，是一种更完善的 Hash 结构实现。如果你需要 “ 键值对 ” 的数据结构， Map 比 Object 更
合适。

var m = new Map();
var o = {p: "Hello World"};
m.set(o, "content")
m.get(o) // "content"
m.has(o) // true
m.delete(o) // true
m.has(o) // false
上面代码使用 set 方法，将对象 o 当作 m 的一个键，然后又使用 get 方法读取这个键，接着使用 delete 方法删除了
这个键。
作为构造函数， Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组

var map = new Map([["name", " 张三 "], ["title", "Author"]]);
map.size // 2
map.has("name") // true
map.get("name") // " 张三 "
map.has("title") // true
map.get("title") // "Author"
上面代码在新建 Map 实例时，就指定了两个键 name  和 title  。
Map 构造函数接受数组作为参数，实际上执行的是下面的算法。
var items = [
["name", " 张三 "],
["title", "Author"]
];
var map = new Map();
items.forEach(([key, value]) => map.set(key, value));
如果对同一个键多次赋值，后面的值将覆盖前面的值。
let map = new Map();
map
.set(1, 'aaa')
.set(1, 'bbb');
map.get(1) // "bbb"
上面代码对键 1  连续赋值两次，后一次的值覆盖前一次的值。
如果读取一个未知的键，则返回 undefined  。
new Map().get('asfddfsasadf')
// undefined
注意，只有对同一个对象的引用， Map 结构才将其视为同一个键。这一点要非常小心。

注意，只有对同一个对象的引用， Map 结构才将其视为同一个键。这一点要非常小心。
var map = new Map();
map.set(['a'], 555);
map.get(['a']) // undefined
上面代码的 set  和 get  方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因
此 get  方法无法读取该键，返回 undefined  。
同理，同样的值的两个实例，在 Map 结构中被视为两个键。
var map = new Map();
var k1 = ['a'];
var k2 = ['a'];
map
.set(k1, 111)
.set(k2, 222);
map.get(k1) // 111
map.get(k2) // 222
上面代码中，变量 k1  和 k2  的值是一样的，但是它们在 Map 结构中被视为两个键。
由上可知， Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属
性碰撞（ clash ）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作
者的属性同名。
如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等， Map 将其视为一个
键，包括 0 和 -0 。另外，虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。
let map = new Map();
map.set(NaN, 123);
map.get(NaN) // 123
map.set(-0, 123);
map.get(+0) // 123

实例的属性和操作方法
Map 结构的实例有以下属性和操作方法。
（ 1 ） size 属性
size  属性返回 Map 结构的成员总数。
let map = new Map();
map.set('foo', true);
map.set('bar', false);
map.size // 2
（ 2 ） set(key, value)
set  方法设置 key  所对应的键值，然后返回整个 Map 结构。如果 key  已经有值，则键值会被更新，否则
就新生成该键。
var m = new Map();
m.set("edition", 6) //  键是字符串
m.set(262, "standard") //  键是数值
m.set(undefined, "nah") //  键是 undefined
set  方法返回的是 Map 本身，因此可以采用链式写法。
let map = new Map()
.set(1, 'a')
.set(2, 'b')
.set(3, 'c');
（ 3 ） get(key)
get  方法读取 key  对应的键值，如果找不到 key  ，返回 undefined  。
var m = new Map();
var hello = function() {console.log("hello");}
m.set(hello, "Hello ES6!") //  键是函数
m.get(hello) // Hello ES6!
（ 4 ） has(key)
has  方法返回一个布尔值，表示某个键是否在 Map 数据结构中。
var m = new Map();
m.set("edition", 6);
m.set(262, "standard");
m.set(undefined, "nah");
m.has("edition") // true
m.has("years") // false
m.has(262) // true
m.has(undefined) // true
（ 5 ） delete(key)
delete  方法删除某个键，返回 true 。如果删除失败，返回 false 。
var m = new Map();
m.set(undefined, "nah");
m.has(undefined) // true
m.delete(undefined)
m.has(undefined) // false
（ 6 ） clear()
clear  方法清除所有成员，没有返回值。
let map = new Map();
map.set('foo', true);
map.set('bar', false);
map.size // 2
map.clear()
map.size // 0
遍历方法
Map 原生提供三个遍历器生成函数和一个遍历方法。
keys() ：返回键名的遍历器。
values() ：返回键值的遍历器。
entries() ：返回所有成员的遍历器。
forEach() ：遍历 Map 的所有成员。
下面是使用实例。
let map = new Map([
['F', 'no'],
['T', 'yes'],
]);
for (let key of map.keys()) {
console.log(key);
}
// "F"
// "T"
for (let value of map.values()) {
console.log(value);
}
// "no"
// "yes"
for (let item of map.entries()) {
console.log(item[0], item[1]);
}
// "F" "no"
// "T" "yes"
//  或者
for (let [key, value] of map.entries()) {
console.log(key, value);
}
//  等同于使用 map.entries()
for (let [key, value] of map) {
console.log(key, value);
}
上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（ Symbol.iterator  属性），就
是 entries  方法。
map[Symbol.iterator] === map.entries
// true
Map 结构转为数组结构，比较快速的方法是结合使用扩展运算符（ ... ）。
let map = new Map([
[1, 'one'],
[2, 'two'],
[3, 'three'],
]);
[...map.keys()]
// [1, 2, 3]
[...map.values()]
// ['one', 'two', 'three']
[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]
[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
结合数组的 map 方法、 filter 方法，可以实现 Map 的遍历和过滤（ Map 本身没有 map 和 filter 方法）。
let map0 = new Map()
.set(1, 'a')
.set(2, 'b')
.set(3, 'c');
let map1 = new Map(
[...map0].filter(([k, v]) => k < 3)
);
//  产生 Map 结构 {1 => 'a', 2 => 'b'}
let map2 = new Map(
[...map0].map(([k, v]) => [k * 2, '_' + v])
);
//  产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
此外， Map 还有一个 forEach 方法，与数组的 forEach 方法类似，也可以实现遍历。
map.forEach(function(value, key, map)) {
console.log("Key: %s, Value: %s", key, value);
};
forEach 方法还可以接受第二个参数，用来绑定 this 。
var reporter = {
report: function(key, value) {
console.log("Key: %s, Value: %s", key, value);
}
};
map.forEach(function(value, key, map) {
this.report(key, value);
}, reporter);
上面代码中， forEach  方法的回调函数的 this  ，就指向 reporter  。


与其他数据结构的互相转换


（ 1 ） Map 转为数组
前面已经提过， Map 转为数组最方便的方法，就是使用扩展运算符（ ... ）。
let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]


（ 2 ）数组转为 Map
将数组转入 Map 构造函数，就可以转为 Map 。
new Map([[true, 7], [{foo: 3}, ['abc']]])
// Map {true => 7, Object {foo: 3} => ['abc']}

 3 ） Map 转为对象
如果所有 Map 的键都是字符串，它可以转为对象。
function strMapToObj(strMap) {
let obj = Object.create(null);
for (let [k,v] of strMap) {
obj[k] = v;
}
return obj;
}
let myMap = new Map().set('yes', true).set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }

（ 4 ）对象转为 Map
function objToStrMap(obj) {
let strMap = new Map();
for (let k of Object.keys(obj)) {
strMap.set(k, obj[k]);
}
return strMap;
}
objToStrMap({yes: true, no: false})
// [ [ 'yes', true ], [ 'no', false ] ]

 5 ） Map 转为 JSON
Map 转为 JSON 要区分两种情况。一种情况是， Map 的键名都是字符串，这时可以选择转为对象 JSON 。
function strMapToJson(strMap) {
return JSON.stringify(strMapToObj(strMap));
}
let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'
另一种情况是， Map 的键名有非字符串，这时可以选择转为数组 JSON 。
function mapToArrayJson(map) {
return JSON.stringify([...map]);
}
let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
（ 6 ） JSON 转为 Map
JSON 转为 Map ，正常情况下，所有键名都是字符串。
function jsonToStrMap(jsonStr) {
return objToStrMap(JSON.parse(jsonStr));
}
jsonToStrMap('{"yes":true,"no":false}')
// Map {'yes' => true, 'no' => false}
但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这
时，它可以一一对应地转为 Map 。这往往是数组转为 JSON 的逆操作。
function jsonToMap(jsonStr) {
return new Map(JSON.parse(jsonStr));
}
jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true => 7, Object {foo: 3} => ['abc']}

WeakMap
WeakMap  结构与 Map  结构基本类似，唯一的区别是它只接受对象作为键名（ null  除外），不接受其他
类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。
var map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
上面代码中，如果将 1  和 Symbol  作为 WeakMap 的键名，都会报错。
WeakMap  的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的
对象可能会被自动回收。当对象被回收后， WeakMap  自动移除对应的键值对。典型应用是，一个对应 DOM
元素的 WeakMap  结构，当某个 DOM 元素被清除，其所对应的 WeakMap  记录就会自动被移除。基本
上， WeakMap  的专用场合就是，它的键所对应的对象，可能会在将来消失。 WeakMap  结构有助于防止内
存泄漏。
下面是 WeakMap  结构的一个例子，可以看到用法上与 Map  几乎一样。
var wm = new WeakMap();
var element = document.querySelector(".element");
wm.set(element, "Original");
wm.get(element) // "Original"
element.parentNode.removeChild(element);
element = null;
wm.get(element) // undefined
上面代码中，变量 wm  是一个 WeakMap  实例，我们将一个 DOM  节点 element  作为键名，然后销毁这个
节点， element  对应的键就自动消失了，再引用这个键名就返回 undefined  。
WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没
有 key()  、 values()  和 entries()  方法），也没有 size  属性；二是无法清空，即不支持 clear  方
法。这与 WeakMap  的键不被计入引用、被垃圾回收机制忽略有关。因此， WeakMap  只有四个方法可
用： get()  、 set()  、 has()  、 delete()  。
var wm = new WeakMap();
wm.size
// undefined
wm.forEach
// undefined
前文说过， WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。
let myElement = document.getElementById('logo');
let myWeakmap = new WeakMap();
myWeakmap.set(myElement, {timesClicked: 0});
myElement.addEventListener('click', function() {
let logoData = myWeakmap.get(myElement);
logoData.timesClicked++;
myWeakmap.set(myElement, logoData);
}, false);
上面代码中， myElement  是一个 DOM 节点，每当发生 click 事件，就更新一下状态。我们将这个状态作为键
值放在 WeakMap 里，对应的键名就是 myElement  。一旦这个 DOM 节点删除，该状态就会自动消失，不存在
内存泄漏风险。
WeakMap 的另一个用处是部署私有属性。
let _counter = new WeakMap();
let _action = new WeakMap();
class Countdown {
constructor(counter, action) {
_counter.set(this, counter);
_action.set(this, action);
}
dec() {
let counter = _counter.get(this);
if (counter < 1) return;
counter--;
_counter.set(this, counter);
if (counter === 0) {
_action.get(this)();
}
}
}
let c = new Countdown(2, () => console.log('DONE'));
c.dec()
c.dec()
// DONE
上面代码中， Countdown 类的两个内部属性 _counter  和 _action  ，是实例的弱引用，所以如果删除实
例，它们也就随之消失，不会造成内存泄漏



Iterator 和 for...of 循环

Iterator （遍历器）的概念
JavaScript 原有的表示 “ 集合 ” 的数据结构，主要是数组（ Array ）和对象（ Object ）， ES6 又添加了 Map 和 Set 。
这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map ， Map
的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
遍历器（ Iterator ）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数
据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员
能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 for...of  循环， Iterator 接口主要供 for...of  消
费。
Iterator 的遍历过程是这样的。

Iterator 的遍历过程是这样的。
（ 1 ）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对
象。
（ 2 ）第一次调用指针对象的 next  方法，可以将指针指向数据结构的第一个成员。
（ 3 ）第二次调用指针对象的 next  方法，指针就指向数据结构的第二个成员。
（ 4 ）不断调用指针对象的 next  方法，直到它指向数据结构的结束位置。
每一次调用 next  方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包
含 value  和 done  两个属性的对象。其中， value  属性是当前成员的值， done  属性是一个布尔值，表
示遍历是否结束。

下面是一个模拟 next  方法返回值的例子。
var it = makeIterator(['a', 'b']);
it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }
function makeIterator(array) {
var nextIndex = 0;
return {
next: function() {
return nextIndex < array.length ?
{value: array[nextIndex++], done: false} :
{value: undefined, done: true};
}
};
}
上面代码定义了一个 makeIterator  函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数
组 ['a', 'b']  执行这个函数，就会返回该数组的遍历器对象（即指针对象） it  。

指针对象的 next  方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 next  方
法，指针就会指向数组的下一个成员。第一次调用，指向 a  ；第二次调用，指向 b  。
next  方法返回一个对象，表示当前数据成员的信息。这个对象具有 value  和 done  两个属
性， value  属性返回当前位置的成员， done  属性是一个布尔值，表示遍历是否结束，即是否还有必要再
一次调用 next  方法。
总之，调用指针对象的 next  方法，就可以遍历事先给定的数据结构。
对于遍历器对象来说， done: false  和 value: undefined  属性都是可以省略的，因此上面
的 makeIterator  函数可以简写成下面的形式。
function makeIterator(array) {
var nextIndex = 0;
return {
next: function() {
return nextIndex < array.length ?
{value: array[nextIndex++]} :
{done: true};
}
};
}
由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开
的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限
运行的遍历器对象的例子。
var it = idMaker();
it.next().value // '0'
it.next().value // '1'
it.next().value // '2'
// ...
function idMaker() {
var index = 0;
return {
next: function() {
return {value: index++, done: false};
}
};
}
上面的例子中，遍历器生成函数 idMaker  ，返回一个遍历器对象（即指针对象）。但是并没有对应的数据
结构，或者说，遍历器对象自己描述了一个数据结构出来。
在 ES6 中，有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for...of  循环遍
历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了 Symbol.iterator  属性（详见下
文），另外一些数据结构没有。凡是部署了 Symbol.iterator  属性的数据结构，就称为部署了遍历器接
口。调用这个接口，就会返回一个遍历器对象。
如果使用 TypeScript 的写法，遍历器接口（ Iterable ）、指针对象（ Iterator ）和 next 方法返回值的规格可以描述
如下。
interface Iterable {
[Symbol.iterator]() : Iterator,
}
interface Iterator {
next(value?: any) : IterationResult,
}
interface IterationResult {
value: any,
done: boolean,
}

数据结构的默认 Iterator 接口
Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for...of  循环（详见下文）。
当使用 for...of  循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。
ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator  属性，或者说，一个数据结构只要具
有 Symbol.iterator  属性，就可以认为是 “ 可遍历的 ” （ iterable ）。调用 Symbol.iterator  方法，就会得
到当前数据结构默认的遍历器生成函数。 Symbol.iterator  本身是一个表达式，返回 Symbol 对象
的 iterator  属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（请参考 Symbol
一章）。
在 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、 Set 和 Map 结构。

let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();
iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }

上面代码中，变量 arr  是一个数组，原生就具有遍历器接口，部署在 arr  的 Symbol.iterator  属性上
面。所以，调用这个属性，就得到遍历器对象。
上面提到，原生就部署 Iterator 接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函
数， for...of  循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己
在 Symbol.iterator  属性上面部署，这样才会被 for...of  循环遍历。
对象（ Object ）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定
的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接
口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上
被当作 Map 结构使用， ES5 没有 Map 结构，而 ES6 原生提供了。
一个对象如果要有可被 for...of  循环调用的 Iterator 接口，就必须在 Symbol.iterator  的属性上部署遍历
器生成方法（原型链上的对象具有该方法也可）。

调用 Iterator 接口的场合
有一些场合会默认调用 Iterator 接口（即 Symbol.iterator  方法），除了下文会介绍的 for...of  循环，还
有几个别的场合。
（ 1 ）解构赋值
对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator  方法。
let set = new Set().add('a').add('b').add('c');
let [x,y] = set;
// x='a'; y='b'
let [first, ...rest] = set;
// first='a'; rest=['b','c'];
（ 2 ）扩展运算符
扩展运算符（ ... ）也会调用默认的 iterator 接口。
//  例一
var str = 'hello';
[...str] // ['h','e','l','l','o']
//  例二
let arr = ['b', 'c'];
['a', ...arr, 'd']
// ['a', 'b', 'c', 'd']
上面代码的扩展运算符内部就调用 Iterator 接口。
实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某
个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。
let arr = [...iterable];
（ 3 ） yield*
yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。
let generator = function* () {
yield 1;
yield* [2,3,4];
yield 5;
};
var iterator = generator();
iterator.next() // { value: 1, done: false }
iterator.next() // { value: 2, done: false }
iterator.next() // { value: 3, done: false }
iterator.next() // { value: 4, done: false }
iterator.next() // { value: 5, done: false }
iterator.next() // { value: undefined, done: true }
（ 4 ）其他场合
由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是
一些例子。
for...of
Array.from()
Map(), Set(), WeakMap(), WeakSet() （比如 new Map([['a',1],['b',2]])  ）
Promise.all()
Promise.race()

字符串的 Iterator 接口



var someString = "hi";
typeof someString[Symbol.iterator]
// "function"
var iterator = someString[Symbol.iterator]();
iterator.next() // { value: "h", done: false }
iterator.next() // { value: "i", done: false }
iterator.next() // { value: undefined, done: true }
上面代码中，调用 Symbol.iterator  方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现
对于字符串的遍历。

var str = new String("hi");
[...str] // ["h", "i"]
str[Symbol.iterator] = function() {
return {
next: function() {
if (this._first) {
this._first = false;
return { value: "bye", done: false };
} else {
return { done: true };
}
},
_first: true
};
};
[...str] // ["bye"]
str // "hi"
上面代码中，字符串 str 的 Symbol.iterator  方法被修改了，所以扩展运算符（ ...  ）返回的值变成
了 bye  ，而字符串本身还是 hi  。


for...of 循环
ES6 借鉴 C++ 、 Java 、 C# 和 Python 语言，引入了 for...of  循环，作为遍历所有数据结构的统一的方法。一
个数据结构只要部署了 Symbol.iterator  属性，就被视为具有 iterator 接口，就可以用 for...of  循环遍历
它的成员。也就是说， for...of  循环内部调用的是数据结构的 Symbol.iterator  方法。
for...of 循环可以使用的范围包括数组、 Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、 DOM
NodeList 对象）、后文的 Generator 对象，以及字符串。

数组
数组原生具备 iterator 接口， for...of  循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证
明。
const arr = ['red', 'green', 'blue'];
let iterator = arr[Symbol.iterator]();
for(let v of arr) {
console.log(v); // red green blue
}
for(let v of iterator) {
console.log(v); // red green blue
}
上面代码的 for...of  循环的两种写法是等价的

JavaScript 原有的 for...in  循环，只能获得对象的键名，不能直接获取键值。 ES6 提供 for...of  循环，
允许遍历获得键值。
var arr = ['a', 'b', 'c', 'd'];
for (let a in arr) {
console.log(a); // 0 1 2 3
}
for (let a of arr) {
console.log(a); // a b c d
}
上面代码表明， for...in  循环读取键名， for...of  循环读取键值。如果要通过 for...of  循环，获取
数组的索引，可以借助数组实例的 entries  方法和 keys  方法，参见《数组的扩展》章节。
for...of  循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for...in  循
环也不一样。

let arr = [3, 5, 7];
arr.foo = 'hello';
for (let i in arr) {
console.log(i); // "0", "1", "2", "foo"
}
for (let i of arr) {
console.log(i); // "3", "5", "7"
}
上面代码中， for...of  循环不会返回数组 arr  的 foo  属性。

Set 和 Map 结构
Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用 for...of  循环。
var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
for (var e of engines) {
console.log(e);
}
// Gecko
// Trident
// Webkit
var es6 = new Map();
es6.set("edition", 6);
es6.set("committee", "TC39");
es6.set("standard", "ECMA-262");
for (var [name, value] of es6) {
console.log(name + ": " + value);
}
// edition: 6
// committee: TC39
// standard: ECMA-262
上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被
添加进数据结构的顺序。其次， Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，
该数组的两个成员分别为当前 Map 成员的键名和键值。


let map = new Map().set('a', 1).set('b', 2);
for (let pair of map) {
console.log(pair);
}
// ['a', 1]
// ['b', 2]
for (let [key, value] of map) {
console.log(key + ' : ' + value);
}
// a : 1
// b : 2


计算生成的数据结构
有些数据结构是在现有数据结构的基础上，计算生成的。比如， ES6 的数组、 Set 、 Map 都部署了以下三个方
法，调用后都返回遍历器对象。
entries()  返回一个遍历器对象，用来遍历 [ 键名 ,  键值 ]  组成的数组。对于数组，键名就是索引
值；对于 Set ，键名与键值相同。 Map 结构的 iterator 接口，默认就是调用 entries 方法。
keys()  返回一个遍历器对象，用来遍历所有的键名。
values()  返回一个遍历器对象，用来遍历所有的键值。
这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。
let arr = ['a', 'b', 'c'];
for (let pair of arr.entries()) {
console.log(pair);
}
// [0, 'a']
// [1, 'b']
// [2, 'c']

类似数组的对象
类似数组的对象包括好几类。下面是 for...of  循环用于字符串、 DOM NodeList 对象、 arguments 对象的例
子。

//  字符串
let str = "hello";
for (let s of str) {
console.log(s); // h e l l o
}
// DOM NodeList 对象
let paras = document.querySelectorAll("p");
for (let p of paras) {
p.classList.add("test");
}
// arguments 对象
function printArgs() {
for (let x of arguments) {
console.log(x);
}
}
printArgs('a', 'b');
// 'a'
// 'b'

对于字符串来说， for...of  循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。
for (let x of 'a\uD83D\uDC0A') {
console.log(x);
}
// 'a'
// '\uD83D\uDC0A'
并不是所有类似数组的对象都具有 iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数
组。

let arrayLike = { length: 2, 0: 'a', 1: 'b' };
//  报错
for (let x of arrayLike) {
console.log(x);
}
//  正确
for (let x of Array.from(arrayLike)) {
console.log(x);
}

对象
对于普通的对象， for...of  结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样
情况下， for...in  循环依然可以用来遍历键名。
var es6 = {
edition: 6,
committee: "TC39",
standard: "ECMA-262"
};
for (e in es6) {
console.log(e);
}
// edition
// committee
// standard
for (e of es6) {
console.log(e);
}
// TypeError: es6 is not iterable
上面代码表示，对于普通的对象， for...in  循环可以遍历键名， for...of  循环会报错。
一种解决方法是，使用 Object.keys  方法将对象的键名生成一个数组，然后遍历这个数组。
for (var key of Object.keys(someObject)) {
console.log(key + ": " + someObject[key]);
}
在对象上部署 iterator 接口的代码，参见本章前面部分。一个方便的方法是将数组的 Symbol.iterator  属
性，直接赋值给其他对象的 Symbol.iterator  属性。比如，想要让 for...of  环遍历 jQuery 对象，只要加
上下面这一行就可以了。
jQuery.prototype[Symbol.iterator] =
Array.prototype[Symbol.iterator];
另一个方法是使用 Generator 函数将对象重新包装一下。
function* entries(obj) {
for (let key of Object.keys(obj)) {
yield [key, obj[key]];
}
}
for (let [key, value] of entries(obj)) {
console.log(key, "->", value);
}
// a -> 1
// b -> 2
// c -> 3

for(var i=0;i<100;i++){if(i<10){console.log(i)else{return}}}









